#!/usr/bin/python3

import curses

superscalar_ways = 3
rob = []
prf = []
map_table = []
rs = []
proc2Imem_addr = []
fetch_packet = []
fetch_dispatch_packet = []
dispatch_rs_packet = []
dispatch_fetch_packet = []
rob_dispatch_packet = []
dispatch_rob_packet = []
dispatch_maptable_packet = []
rs_issue_packet = []
issue_packet = []
issue_fu_packet = []

def read_pipeline_output(filepath):
    with open(filepath, 'r') as fo:
        while True:
            line = fo.readline()
            if not line:
                return cycle # total number of cycles
            
            line = line.strip('\n')
            if line[:5] == "cycle":
                cycle = int(line.split()[-1])
                rob.append([])
                prf.append([])
                map_table.append([])
                rs.append([])
                fetch_packet.append([])
                fetch_dispatch_packet.append([])
                proc2Imem_addr.append([])
                dispatch_rs_packet.append([])
                rob_dispatch_packet.append([])
                dispatch_fetch_packet.append([])
                dispatch_rob_packet.append([])
                dispatch_maptable_packet.append([])
                rs_issue_packet.append([])
                issue_packet.append([])
                issue_fu_packet.append([])
            elif line == "ROB Table":
                readnlines(fo, cycle, rob, 33)
            elif line == "Physical Register File":
                readnlines(fo, cycle, prf, 33)
            elif line == "Maptable":
                readnlines(fo, cycle, map_table, 32)
            elif line == "RS Table":
                readnlines(fo, cycle, rs, 34)
            elif line == "FETCH":
                readnlines(fo, cycle, proc2Imem_addr, 1 + superscalar_ways)
                readnlines(fo, cycle, fetch_packet, 1 + superscalar_ways)
                readnlines(fo, cycle, fetch_dispatch_packet, 1 + superscalar_ways)
            elif line == "DISPATCH":
                readnlines(fo, cycle, rob_dispatch_packet, 1 + superscalar_ways)
                readnlines(fo, cycle, dispatch_fetch_packet, 2)
                readnlines(fo, cycle, dispatch_rs_packet, 1 + superscalar_ways)
                readnlines(fo, cycle, dispatch_rob_packet, 1 + superscalar_ways)
                readnlines(fo, cycle, dispatch_maptable_packet, 1 + superscalar_ways)
            elif line == "ISSUE":
                readnlines(fo, cycle, rs_issue_packet, 1 + superscalar_ways)
                readnlines(fo, cycle, issue_packet, 1 + superscalar_ways)
                readnlines(fo, cycle, issue_fu_packet, 1 + superscalar_ways)

def readnlines(fo, cycle, lst, n):
    for _ in range(n):
        line = fo.readline().strip('\n')
        lst[cycle].append(line)
    return

class Cycle():
    def __init__(self):
        self.now = 0
        self.limit = [0, 999]
        return

    def add_to_cycle(self, num):
        self.now += num
        if self.now < self.limit[0]:
            self.now = self.limit[0]
        elif self.now > self.limit[1]:
            self.now = self.limit[1]
        return

    def move_to_cycle(self, num):
        self.now = num
        if self.now < self.limit[0]:
            self.now = self.limit[0]
        elif self.now > self.limit[1]:
            self.now = self.limit[1]
        return

class Page():
    def __init__(self):
        self.pages = ["Modules", "Stages"]
        self.curr_index = 0
        return
    
    def next_page(self):
        self.curr_index = (self.curr_index + 1) % len(self.pages)
        return
    
    def curr_page(self):
        return self.pages[self.curr_index]


def new_window(title, nlines, ncols, begin_y, begin_x):
    win = curses.newwin(nlines, ncols, begin_y, begin_x)
    win.border()
    win.addstr(0, max(0, (ncols - 1) // 2 - len(title) // 2), title, curses.A_BOLD)
    win.refresh()
    return win


def main(stdscr):

    def update_ui_main():

        # create window for Keys
        wins["keys"] = new_window(title="Keys", 
                                  nlines=11, 
                                  ncols=15, 
                                  begin_y=0, 
                                  begin_x=0
                                  )
        wins["keys"].addstr(1, 1, "Q: quit")
        wins["keys"].addstr(2, 1, "L: next cycle")
        wins["keys"].addstr(3, 1, "J: prev cycle")
        wins["keys"].addstr(4, 1, "I: +10 cycles")
        wins["keys"].addstr(5, 1, "K: -10 cycles")
        wins["keys"].addstr(6, 1, f"G: go to {goto_input[-3:]:3s}", curses.A_REVERSE * recording)
        wins["keys"].addstr(7, 1, "T: end go to ")
        wins["keys"].addstr(8, 1, "B: backspace ")
        wins["keys"].addstr(9, 1, "C: next page ")
        wins["keys"].refresh()

        # create window for Cycle
        wins["cycle"] = new_window(title="Cycle", 
                                nlines=3, 
                                ncols=15, 
                                begin_y=11, 
                                begin_x=0
                                )
        wins['cycle'].addstr(1, 1, f"     {cycle.now:3d}     ")
        wins['cycle'].refresh()

        return
    

    def update_ui_modules():

        # create window for Reorder Buffer (RoB)
        wins["rob"] = new_window(title="RoB", 
                                 nlines=35, 
                                 ncols=50, 
                                 begin_y=0, 
                                 begin_x=wins['keys'].getbegyx()[1] + wins['keys'].getmaxyx()[1]
                                 )
        for i, line in enumerate(rob[min(cycle.now, max_cycle)]):
            wins['rob'].addstr(i+1, 1, line)
        wins["rob"].refresh()

        # create window for Physical Register File (PRF)
        wins["prf"] = new_window(title="PRF", 
                                 nlines=35, 
                                 ncols=31, 
                                 begin_y=0, 
                                 begin_x=wins['rob'].getbegyx()[1] + wins['rob'].getmaxyx()[1]
                                 )
        for i, line in enumerate(prf[min(cycle.now, max_cycle)]):
            wins['prf'].addstr(i+1, 1, line)
        wins["prf"].refresh()

        # create window for Reservation Stations (RS)
        wins["rs"] = new_window(title="RS", 
                                nlines=36, 
                                ncols=64, 
                                begin_y=0, 
                                begin_x=wins['prf'].getbegyx()[1] + wins['prf'].getmaxyx()[1]
                                )
        for i, line in enumerate(rs[min(cycle.now, max_cycle)]):
            wins['rs'].addstr(i+1, 1, line)
        wins["rs"].refresh()

        # create window for Map Table
        wins["map_table"] = new_window(title="Map Table", 
                                    nlines=18, 
                                    ncols=15, 
                                    begin_y=14, 
                                    begin_x=0
                                    )
        for i in range(16):
            wins['map_table'].addstr(i + 1, 1, map_table[min(cycle.now, max_cycle)][i] + '|' + map_table[min(cycle.now, max_cycle)][i + 16])
        wins["map_table"].refresh()

        return
    

    def update_ui_stages():

        # create window for Fetch
        wins["proc2Imem_addr"] = new_window(title="proc2Imem_addr", 
                                   nlines=6, 
                                   ncols=15, 
                                   begin_y=0, 
                                   begin_x=wins['keys'].getbegyx()[1] + wins['keys'].getmaxyx()[1]
                                   )
        for i, line in enumerate(proc2Imem_addr[min(cycle.now, max_cycle)]):
            wins['proc2Imem_addr'].addstr(i+1, 1, line)
        wins["proc2Imem_addr"].refresh()

        # create window for fetch_packet
        wins["fetch_packet"] = new_window(title="fetch_packet", 
                                   nlines=6, 
                                   ncols=39, 
                                   begin_y=0, 
                                   begin_x=wins['proc2Imem_addr'].getbegyx()[1] + wins['proc2Imem_addr'].getmaxyx()[1]
                                   )
        for i, line in enumerate(fetch_packet[min(cycle.now, max_cycle)]):
            wins['fetch_packet'].addstr(i+1, 1, line)
        wins["fetch_packet"].refresh()

        # create window for fetch_dispatch_packet
        wins["fetch_dispatch_packet"] = new_window(title="fetch_dispatch_packet", 
                                   nlines=6, 
                                   ncols=39, 
                                   begin_y=0, 
                                   begin_x=wins['fetch_packet'].getbegyx()[1] + wins['fetch_packet'].getmaxyx()[1]
                                   )
        for i, line in enumerate(fetch_dispatch_packet[min(cycle.now, max_cycle)]):
            wins['fetch_dispatch_packet'].addstr(i+1, 1, line)
        wins["fetch_dispatch_packet"].refresh()

        # create window for dispatch_rs_packet
        wins["rob_dispatch_packet"] = new_window(title="rob_dispatch", 
                                   nlines=6, 
                                   ncols=13, 
                                   begin_y=0, 
                                   begin_x=wins['fetch_dispatch_packet'].getbegyx()[1] + wins['fetch_dispatch_packet'].getmaxyx()[1]
                                   )
        for i, line in enumerate(rob_dispatch_packet[min(cycle.now, max_cycle)]):
            wins['rob_dispatch_packet'].addstr(i+1, 1, line)
        wins["rob_dispatch_packet"].refresh()

        # create window for dispatch_fetch_packet
        wins["dispatch_fetch_packet"] = new_window(title="dispatch_fetch", 
                                   nlines=4, 
                                   ncols=21, 
                                   begin_y=0, 
                                   begin_x=wins['rob_dispatch_packet'].getbegyx()[1] + wins['rob_dispatch_packet'].getmaxyx()[1]
                                   )
        for i, line in enumerate(dispatch_fetch_packet[min(cycle.now, max_cycle)]):
            wins['dispatch_fetch_packet'].addstr(i+1, 1, line)
        wins["dispatch_fetch_packet"].refresh()
        
        # create window for dispatch_rs_packet
        wins["dispatch_rs_packet"] = new_window(title="dispatch_rs_packet", 
                                   nlines=6, 
                                   ncols=126, 
                                   begin_y=wins['fetch_packet'].getbegyx()[0] + wins['fetch_packet'].getmaxyx()[0], 
                                   begin_x=wins['keys'].getbegyx()[1] + wins['keys'].getmaxyx()[1]
                                   )
        for i, line in enumerate(dispatch_rs_packet[min(cycle.now, max_cycle)]):
            wins['dispatch_rs_packet'].addstr(i+1, 1, line)
        wins["dispatch_rs_packet"].refresh()

        # create window for dispatch_rob_packet
        wins["dispatch_rob_packet"] = new_window(title="dispatch_rob_packet", 
                                   nlines=6, 
                                   ncols=27, 
                                   begin_y=wins['dispatch_rs_packet'].getbegyx()[0] + wins['dispatch_rs_packet'].getmaxyx()[0], 
                                   begin_x=wins['keys'].getbegyx()[1] + wins['keys'].getmaxyx()[1]
                                   )
        for i, line in enumerate(dispatch_rob_packet[min(cycle.now, max_cycle)]):
            wins['dispatch_rob_packet'].addstr(i+1, 1, line)
        wins["dispatch_rob_packet"].refresh()

        # create window for dispatch_maptable_packet
        wins["dispatch_maptable_packet"] = new_window(title="dispatch_map", 
                                   nlines=6, 
                                   ncols=13, 
                                   begin_y=wins['dispatch_rs_packet'].getbegyx()[0] + wins['dispatch_rs_packet'].getmaxyx()[0], 
                                   begin_x=wins['dispatch_rob_packet'].getbegyx()[1] + wins['dispatch_rob_packet'].getmaxyx()[1]
                                   )
        for i, line in enumerate(dispatch_maptable_packet[min(cycle.now, max_cycle)]):
            wins['dispatch_maptable_packet'].addstr(i+1, 1, line)
        wins["dispatch_maptable_packet"].refresh()

        # create window for rs_issue_packet
        wins["rs_issue_packet"] = new_window(title="rs_issue_packet", 
                                   nlines=6, 
                                   ncols=len(rs_issue_packet[0][0]) + 2, 
                                   begin_y=wins['dispatch_maptable_packet'].getbegyx()[0] + wins['dispatch_maptable_packet'].getmaxyx()[0], 
                                   begin_x=wins['keys'].getbegyx()[1] + wins['keys'].getmaxyx()[1]
                                   )
        for i, line in enumerate(rs_issue_packet[min(cycle.now, max_cycle)]):
            wins['rs_issue_packet'].addstr(i+1, 1, line)
        wins["rs_issue_packet"].refresh()

        # create window for issue_packet
        wins["issue_packet"] = new_window(title="issue_packet", 
                                   nlines=6, 
                                   ncols=len(issue_packet[0][0]) + 2, 
                                   begin_y=wins['dispatch_maptable_packet'].getbegyx()[0] + wins['dispatch_maptable_packet'].getmaxyx()[0], 
                                   begin_x=wins['rs_issue_packet'].getbegyx()[1] + wins['rs_issue_packet'].getmaxyx()[1]
                                   )
        for i, line in enumerate(issue_packet[min(cycle.now, max_cycle)]):
            wins['issue_packet'].addstr(i+1, 1, line)
        wins["issue_packet"].refresh()

        # create window for issue_fu_packet
        wins["issue_fu_packet"] = new_window(title="issue_fu_packet", 
                                   nlines=6, 
                                   ncols=len(issue_fu_packet[0][0]) + 2, 
                                   begin_y=wins['rs_issue_packet'].getbegyx()[0] + wins['rs_issue_packet'].getmaxyx()[0], 
                                   begin_x=wins['keys'].getbegyx()[1] + wins['keys'].getmaxyx()[1]
                                   )
        for i, line in enumerate(issue_fu_packet[min(cycle.now, max_cycle)]):
            wins['issue_fu_packet'].addstr(i+1, 1, line)
        wins["issue_fu_packet"].refresh()

        return

    # initialization
    wins = {"main": stdscr}
    curses.curs_set(False)
    wins["main"].clear()
    wins["main"].refresh()
    
    goto_input = ""
    recording = False
    key_press = ""

    # main loop
    while True:
        height, width = wins["main"].getmaxyx()
        if height < 25 or width < 100:
            wins['main'].clear()
            wins["main"].addstr(0, 0, "Not enough space!")
            wins["main"].refresh()
            wins["main"].getch()
            continue
        wins["main"].clear()
        wins["main"].refresh()
        update_ui_main()
        if page.curr_page() == "Modules":
            update_ui_modules()
        elif page.curr_page() == "Stages":
            update_ui_stages()

        
        key_press = wins["main"].getch()

        # quit the debugger
        if key_press == ord('q'):
            return
        
        # move cycle count
        if key_press == ord('l'):   
            cycle.add_to_cycle(1)
        elif key_press == ord('j'):   
            cycle.add_to_cycle(-1)
        elif key_press == ord('i'):   
            cycle.add_to_cycle(10)
        elif key_press == ord('k'):   
            cycle.add_to_cycle(-10)

        # go-to function
        elif key_press == ord('g'): # start go-to
            goto_input = ""
            recording = True
        elif recording and key_press == ord('t'): # end go-to
            recording = False
            if goto_input:
                cycle.move_to_cycle(int(goto_input[-3:]))
                goto_input = ""
        elif recording and key_press == ord('b'): # backspace
            goto_input = goto_input[:-1]
        elif recording and 48 <= key_press <= 57: # numbers: 0-9
            char = str(int(chr(key_press)))
            goto_input += char

        # switch page
        elif key_press == ord('c'):
            page.next_page()


if __name__ == "__main__":
    cycle = Cycle()
    page = Page()
    max_cycle = read_pipeline_output("../pipeline.out")
    curses.wrapper(main)